%decls %{
#include <map>
#include <string>
#include <list>
#include <sstream>
#include <iostream>

using namespace std;

class Expr;
typedef list<Expr *> ExprList;
%}

%{
#include "opascal_tree.h"

map<string, int> stable;
string class_name_actual = "";
%}

%option lang="C++"

%node OPNode %abstract %typedef

%node ProgramNode OPNode = {
	string name;
	OPNode 	*typedef_list_node;
	OPNode	*method_impl_list_node;
	OPNode	*var_decl_list_node;
	Statement	*block;
}

//------------------TypeDefList------------------
%node TypeDefList OPNode = {
	OPNode	*class_decl_node;
	OPNode	*next;
}

%node ClassDeclaration OPNode = {
	string class_name;
	OPNode	*inherits_node;
	OPNode	*field_decl_list_node;
	OPNode	*method_decl_list_node;
}

%node InheritsNode OPNode = {
	string class_name;
}

%node FieldDeclList OPNode = {
	OPNode	*field_decl_node;
	OPNode	*next;
}

%node FieldDecl OPNode = {
	string field_type;
	string field_name;
}


//------------------MethodDeclList------------------
%node MethodDeclList OPNode = {
	OPNode	*method_decl_node;
	OPNode	*next;
}

%node MethodDecl OPNode = {
	int method_kind;
	string method_name;
	OPNode *method_type_node;
	OPNode *param_decl_list_node;
	OPNode *modifier_list_node;
}

%node ModifierList OPNode = {
	int modifier;
	OPNode *next;
}

%node ParameterDeclList OPNode = {
	OPNode	*param_decl_node;
	OPNode	*next;
}

%node ParameterDecl OPNode = {
	string param_name;
	OPNode *param_type_node;
}

//------------------MethodImplList------------------
%node MethodImplList OPNode = {
	OPNode	*method_impl_node;
	OPNode	*next;
}

%node MethodImpl OPNode = {
	int method_kind;
	string class_name;
	string method_name;
	OPNode	*method_type_node;
	OPNode	*param_list_node;
	Statement *block;
}

//------------------VarDeclList------------------
%node VarDeclList OPNode = {
	OPNode	*var_decl;
	OPNode	*next;
}

%node VarDecl OPNode = {
	string var_name;
	OPNode *var_type_node;
}

%node OPType OPNode %abstract
%node IntegerType OPType

%node ClassType OPType = {
	string class_name;
}

//......gen_opnode_code()......
%operation %virtual string gen_op_code(OPNode *this)

//VarDeclList
gen_op_code(ClassType) {
	return class_name;
}

gen_op_code(IntegerType) {
	return "int";
}

gen_op_code(VarDecl) {
	string type_name = var_type_node->gen_op_code();
	string variable;

	if (type_name != "int")
		variable = "*" + var_name;
	else
		variable = var_name;

	ostringstream out;
	out << type_name << " " << variable << ";" << endl;

	return out.str();
}

gen_op_code(VarDeclList) {
	string var1 = var_decl->gen_op_code();
	string var2 = "";

	if(next!= NULL)
		var2 = next->gen_op_code();

	return var1 + var2;
}

//MethodImplList
gen_op_code(MethodImpl) {
	string ret = "";
	string param_list = "";
	string stmnts = block->gen_statement_code();

	if (param_list_node != NULL)
		param_list = param_list_node->gen_op_code();

	if (method_kind == 1){//method
		string return_type = method_type_node->gen_op_code();
		ret =	return_type + " " + class_name + "_" + method_name + "(" + param_list + ")" + "{\n" +
				stmnts +
			"}\n";
	} else {//procedure
		ret =	"void " + class_name + "_" + method_name + "(" + param_list + ")" + "{\n" +
				stmnts +
			"}\n";
	}
	return ret;
}

gen_op_code(MethodImplList) {
	string method1 = method_impl_node->gen_op_code();
	string method2 = "";

	if (next != NULL)
		method2 = next->gen_op_code();
	return method1 + method2;
}

//MethodDeclList
gen_op_code(MethodDeclList) {
	string method1 = "";
	string method2 = "";

	if (method_decl_node != NULL)
		method1 = method_decl_node->gen_op_code();

	if (next != NULL)
		method2 = next->gen_op_code();

	return method1 + method2;
}

gen_op_code(MethodDecl) {
	string ret = "";
	string param_list = "";
	string modifiers = "";

	if (param_decl_list_node != NULL)
		param_list = param_decl_list_node->gen_op_code();

	if (modifier_list_node != NULL)
		modifiers = modifier_list_node->gen_op_code();//queeeeeeeeeee

	if (method_kind == 1){//function
		string return_type = method_type_node->gen_op_code();
		ret = return_type + " " + class_name_actual + "_" + method_name + "(" + param_list + ");\n";
	} else {//procedure
		ret = "void " + class_name_actual + "_" + method_name + "(" + param_list + ");\n";
	}
	return ret;
}

gen_op_code(ModifierList) {
	if (modifier)
		return "virtual";
	else
		return "override";
}

gen_op_code(ParameterDeclList) {
	string param1 = param_decl_node->gen_op_code();
	string param2 = "";

	if (next != NULL)
		param2 = ", " + next->gen_op_code();

	return param1 + param2;
}

gen_op_code(ParameterDecl) {
	string param_type = param_type_node->gen_op_code();
	return param_type + " " + param_name;
}

//TypeDefList
gen_op_code(TypeDefList) {
	string class1 = class_decl_node->gen_op_code();
	string class2 = "";

	if (next != NULL)
		class2 = next->gen_op_code();

	return class1 + class2;
}

gen_op_code(ClassDeclaration) {
	class_name_actual = class_name;

	string ret = "";
	string inherits = "";
	string fields = "";
	string methods = "";

	if (inherits_node != NULL)
		inherits = inherits_node->gen_op_code() + " parent;\n";
	if (field_decl_list_node != NULL)
		fields = field_decl_list_node->gen_op_code();
	if (method_decl_list_node != NULL)
		methods = method_decl_list_node->gen_op_code();

	ret =	"typedef struct " + class_name + " {\n" +
			inherits +
			fields +
		"} " + class_name + ";\n\n" +
		methods + "\n\n";

	class_name_actual ="";

	return ret;
}

gen_op_code(InheritsNode) {
	return class_name;
}

gen_op_code(FieldDeclList) {
	return "//FieldDeclList\n";
}

gen_op_code(FieldDecl) {
	return "//FieldDecl\n";
}

gen_op_code(ProgramNode) {
	return "PROGRAMNODEEEEEEE";
}

//------------------Expr------------------
/****Traduccion de op a c****/


/****Arbol de Expresion****/
%node Expr %abstract %typedef

%node BinaryExpr Expr %abstract = {
	Expr *expr1;
	Expr *expr2;
}

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MultExpr BinaryExpr
%node DivExpr BinaryExpr
%node GTExpr BinaryExpr
%node GTEExpr BinaryExpr
%node LTExpr BinaryExpr
%node LTEExpr BinaryExpr
%node NEQExpr BinaryExpr
%node EQExpr BinaryExpr

%node NumExpr Expr = {
	int value;
}

%node IDExpr Expr = {
	char *var_name;
}

%node FuncCallExpr Expr = {
	string class_name;
	string method_name;
	
	ExprList *arguments;
}

%node StringExpr Expr = {
	string value;
}

//......gen_code()......

%operation %virtual string gen_code(Expr *this)


gen_code(AddExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	return v1 + "+" + v2;
}

gen_code(SubExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "-" + v2;
}

gen_code(MultExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "*" + v2;
}

gen_code(DivExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "/" + v2;
}

gen_code(GTExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + ">" + v2;
}

gen_code(GTEExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + ">=" + v2;
}

gen_code(LTExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "<" + v2;
}
gen_code(LTEExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "<=" + v2;
}

gen_code(NEQExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "!=" + v2;
}

gen_code(EQExpr) {
	string v1 = expr1->gen_code();
	string v2 = expr2->gen_code();
	
	return v1 + "==" + v2;
}

gen_code(NumExpr) {
	ostringstream out;
	out << value;
	return out.str();
}

gen_code(StringExpr) {
	return "\"" + value + "\"";
}

gen_code(IDExpr) {
	return var_name;
}

gen_code(FuncCallExpr) {
	ostringstream out;
	
	out << class_name << "_" << method_name << "(";
	
	if (arguments != NULL) {
		ExprList::iterator it = arguments->begin();

		while (it != arguments->end()) {
			Expr *expr = *it;
			out << expr->gen_code();
			it++;
			if (it != arguments->end())
				out << ",";
		}
	}

	out << ")";
	
	return out.str();
}

//------------------Statements------------------

/****Arbol de Sentencias****/
%node Statement %abstract %typedef

%node SeqStatement Statement = {
	Statement *st1;
	Statement *st2;
}

%node IfStatement Statement = {
	Expr *condition;
	Statement *st1;
	Statement *st2;
}

%node WhileStatement Statement = {
	Expr *condition;
	Statement *st;
}

%node MethodCallStatement Statement = {
	string class_name;
	string method_name;
	
	ExprList *arguments;
}

%node AssignStatement Statement = {
	char *var_name;
	Expr *expr;
}

%node WriteStatement Statement %abstract = {
	int statement;
}

%node WriteStatementExpr WriteStatement = {
	Expr *expr;
}

%node WriteStatementStr WriteStatement = {
	string value;
}

//......gen_statement_code()......

/*%operation %virtual void process_tree(OPNode *this)*/

/* Code generation for statement */
%operation %virtual string gen_statement_code(Statement *this)

gen_statement_code(SeqStatement) {
	string code1 = st1->gen_statement_code();
	string code2 = st2->gen_statement_code();

	return code1 + code2;
}

gen_statement_code(AssignStatement) {
	string lval = expr->gen_code();
	ostringstream out;
	
	out << var_name << " = " << lval << ";" << endl;
	return out.str();
}

gen_statement_code(MethodCallStatement) {
	ostringstream out;
	
	out << class_name << "_" << method_name << "(";
	
	if (arguments != NULL) {
		ExprList::iterator it = arguments->begin();

		while (it != arguments->end()) {
			Expr *expr = *it;
			out << expr->gen_code();
			it++;
			if (it != arguments->end())
				out << ",";
		}
	}

	out << ");" << endl;
	
	return out.str();
}

gen_statement_code(IfStatement) {
	string val = condition->gen_code();
	string code1 = st1->gen_statement_code();
	string code2 = st2 != NULL? st2->gen_statement_code() : "";
	ostringstream out;
	
	out << "if (" << val << ") {" << endl;
	out << code1;
	out << "}" << endl;
	if (st2 != NULL) {
		out << "else {" << endl;
		out << code2;
		out << "}" << endl;
	}
	return out.str();
}

gen_statement_code(WhileStatement) {
	string cond_str = condition->gen_code();
	string code = st->gen_statement_code();
	ostringstream out;
	
	out << "while (" << cond_str << ") {" << endl;
	out << code;
	out << "}" << endl;
	
	return out.str();
}

gen_statement_code(WriteStatementExpr) {
	string val = expr->gen_code();
	ostringstream out;
	
	switch (statement) {
		case 0:
			out << "printf(\"%d\", " << val << ");" << endl;
			break;
		case 1:
			out << "printf(\"%d\\n\", " << val << ");" << endl;
			break;
	}
	return out.str();
}

gen_statement_code(WriteStatementStr) {
	ostringstream out;
	
	switch (statement) {
		case 0:
			out << "printf(\"" << value << "\");" << endl;
			break;
		case 1:
			out << "printf(\"" << value << "\\n\");" << endl;
			break;
	}
	
	return out.str();
}

